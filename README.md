# flask-pybo
점프 투 플라스크 clone 레포지토리입니다.
https://wikidocs.net/book/4542


<hr>

# 정리

1장 플라스크 개발 준비
## 플라스크 애플리케이션을 생성하는 코드 : Flask(__name__)
 - __name__이라는 변수에는 모듈명이 담김
 - 즉, 이 파일이 실행되면 pybo.py라는 모듈이 실행됨으로 __name__변수에는 pybo라는 문자열이 담김

## 플라스크는 FLASK_APP 환경변수가 지정되지 않은 경우 자동으로 app.py파일을 기본 애플리케이션으로 인식
 - FLASK_APP 환경변수를 별도로 지정해야한다. 
 - export FLASK_APP=pybo
 
## 디버그 모드 활성화
 - 디버그 모드는 오류가 발생하면 디버깅 결과 메시지를 웹 브라우저에 출력해 준다.
 - 또한 서버 실행중에 프로그램을 변경하면 서버가 자동으로 다시 시작하여 변경된 내용을 적용해 준다.
 - export FLASK_DEBUG=true


2장 플라스크 개발 기초 공사

## 블루 프린트 
 -  라우팅 함수를 체계적으로 관리할 수 있다

## ORM : 데이터베이스에 데이터를 저장하는 테이블을 파이썬 클래스로 만들어 관리하는 기술
### ORM의 장점
 - ORM을 이용하면 데이터베이스 종류에 상관 없이 일관된 코드를 유지할 수 있어서 프로그램을 유지·보수하기가 편리하다. 
 - 내부에서 안전한 SQL 쿼리를 자동으로 생성해 주므로 개발자가 달라도 통일된 쿼리를 작성할 수 있고 오류 발생률도 줄일 수 있다.
 - 모델 : 데이터를 관리하는 데 사용하는 ORM 클래스

## SQLAlchemy : 파이썬 ORM 라이브러리
 - Flask-Migrate 라이브러리를 설치하면 SQLAlchemy도 함께 설치됨
 - pip install flask-migrate

## SQLite :
 - 파이썬 기본 패키지에 포함된 SQLite는 주로 소규모 프로젝트에서 사용하는 가벼운 파일을 기반으로 한 데이터베이스다

db 객체를 create_app 함수 안에서 생성하면 블루프린트와 같은 다른 모듈에서 사용할수 없기 때문에 db, migrate와 같은 객체를 create_app 함수 밖에 생성하고, 해당 객체를 앱에 등록할 때는 create_app 함수에서 init_app 함수를 통해 진행한다.

 → 플라스크는 이런 패턴을 자주 사용!
 
## 데이터베이스 관리 명령어

 - flask db migrate : 모델을 새로 생성하거나 변경할 때 사용 (실행하면 작업파일이 생성된다.)
 - flask db upgrade : 모델의 변경 내용을 실제 데이터베이스에 적용할 때 사용 (위에서 생성된 작업파일을 실행하여 데이터베이스를 변경한다.)

## ForeignKey : 답변은 어떤 질문에 대한 답변인지 알아야함 모델을 서로 연결할 때 사용!

→ `#question.id : question테이블의 id, cascade : 질문이 삭제되면 해당 답변도 삭제`

 - question 속성은 답변 모델에서 질문 모델을 참조하기 위해 추가했다

→ ‘Qustion’ : 참조할 모델명

→ `#backref(역참조 설정) : 한 질문에는 여러개의 답변이 달릴수 있는데 역참조는 이 질문에 달린 답변들을 참조 할 수 있음`

 - `#질문에 해당하는 객체가 a_question이라면 a_question.anwer_set와 같은 코드로 해당 질문에 달린 답변을 참조`

## rollback
 - 커밋한 후 은 취소할 수 없기에 커밋 전에 수행한 작업을 취소할려면 db.session.rollback()으로 되돌리기 할 수 있다.
 
## render_template 함수
  - 템플릿 파일을 화면으로 렌더링 하는 함수이다. 
  - 조회한 질문 목록 데이터를 render_template 함수의 파라미터로 전달하면 템플릿에서 해당 데이터로 화면을 구성할수 있다. 
  - 여기서 사용한 question/question_list.html 파일을 템플릿 파일이라고 부른다.
  
## 템플릿 태그
 - {% 와 %}로 둘러싸인 문장을 템플릿 태그라고 한다. 이 태그가 파이썬 코드와 연결된다.
 
redirect(URL) - URL로 페이지를 이동
url_for(라우팅 함수명) - 라우팅 함수에 매핑되어 있는 URL을 리턴
 - url_for 함수에 전달된 question._list는 question, _list 순서로 해석되어 라우팅 함수를 찾는다. question은 등록된 블루프린트 별칭, _list는 블루프린트에 등록된 함수명이다. 따라서 question._list는 question이라는 별칭으로 등록한 question_views.py 파일의 _list 함수를 의미한다. 
 - _list 함수에 등록된 URL 매핑 규칙은 @bp.route('/list/')이므로 url_for('question._list')는 bp의 프리픽스 URL인 /question/과 /list/가 더해진 /question/list/ URL을 반환한다.
 
 ## request 객체
  - request 객체는 플라스크에서 생성 과정 없이 사용할 수 있는 기본 객체다. 
  - 플라스크는 브라우저의 요청부터 응답까지의 처리 구간에서 request 객체를 사용할 수 있게 해준다. 이 객체를 이용해 브라우저에서 요청한 정보를 확인할 수 있다.
  
 ## CSRF Token" 오류
  - CSRF는 보안 관련 항목으로, form 엘리먼트를 통해 전송된 데이터가 실제 웹 사이트에서 만들어진 데이터인지 검증하는 데 필요한 CSRF 토큰이 빠졌다는 의미다.
 
 ## include 기능
  - 템플릿의 특정 영역을 중복, 반복해서 사용할 경우에 유용하다. 
  - 즉, 중복, 반복하는 템플릿의 특정 영역을 따로 템플릿 파일로 만들고, include 기능으로 그 템플릿을 포함한다. 
  - navbar.html 파일은 base.html 파일에서 1번만 사용되지만 따로 파일로 관리해야 이후 유지·보수하는 데 유리하므로 분리했다.
  
 ## session
  - request와 마찬가지로 플라스크가 자체적으로 생성하여 제공하는 객체이다. 
  - 브라우저가 플라스크 서버에 요청을 보내면 request 객체는 요청할 때마다 새로운 객체가 생성된다. 
  - 하지만 session은 request와 달리 한번 생성하면 그 값을 계속 유지하는 특징이 있다.
  
 ## 쿠키
  - 서버가 웹 브라우저에 발행하는 값이다. 
  - 웹 브라우저가 서버에 어떤 요청을 하면 서버는 쿠키를 생성하여 전송하는 방식으로 응답한다. 그러면 웹 브라우저는 서버에서 받은 쿠키를 저장한다. 
  - 이후 서버에 다시 요청을 보낼 때는 저장한 쿠키를 HTTP 헤더에 담아서 전송한다. 
  - 그러면 서버는 웹 브라우저가 보낸 쿠키를 이전에 발행했던 쿠키값과 비교하여 같은 웹 브라우저에서 요청한 것인지 아닌지를 구분할 수 있다. 
  - 이때 세션은 바로 쿠키 1개당 생성되는 서버의 메모리 공간이라고 할 수 있다.
